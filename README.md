# MyC-Tutorial
## ch04 类和对象

### 4.2 类和对象

#### 4.2.1 类的定义

```c++
class 类名 {
public:
	共有接口
protected:
	保护成员
private:
	私有成员
};
```

#### 4.2.2 访问权限

- 共有类型：定义了外部接口
- 私有类型：只能被类内成员函数访问，类外部任何访问都是非法的
- 保护类型：和私有成员类似，差别继承过程中对新类的影响

> 数据成员应该声明为私有，在书写时公有成员写在最前面

#### 4.2.3 对象

- 声明对象
  类名 对象名

- 访问数据成员

  对象名.数据成员

- 访问函数成员

  对象名.函数成员

#### 4.2.4 类的成员函数

- 类内定义，类外实现，并使用类名限制

  - 类名::函数成员

  ```c++
  返回值类型 类名::成员函数名(参数表)
  {
      函数体
  }
  ```

- 默认参数

  ```c++
  class 类名{
  public:
      返回值类型 成员函数名()(参数列表初始化);
  };
  ```

- 内联成员函数

  - 隐式声明 直接放在函数体内

  ```c++
  返回值类型 fun()
  {
  
  }
  ```

  - 显示声明 使用关键字inline

  ```c++
  inline 返回值类型 成员函数名()
  {
  
  }
  ```


### 4.3 构造函数和析构函数

#### 4.3.1 构造函数

```c++
class 类名{
public:
	类名();
};
```

- 构造函数的作用是初始化对象
- 构造函数的名字与类名相同，而且没有返回值，通常被声明为共有函数
- 构造函数在对象创建时被默认调用
- 无需提供参数的构造函数称为默认构造函数，如果没写构造函数，系统默认生成一个隐含的构造函数，参数列表和函数体均为空
- 如果声明了构造函数(无论是否有参数)，编译器便不会为之生成隐含的构造函数
- 构造函数可以是直接访问所有的数据成员，可以是内联函数，可以带有参数表，可以带默认值，可以重载

> 如果定义了构造函数，编译器不会生成隐含的默认构造函数

#### 4.3.2 复制构造函数

```c++
class 类名{
public:
	类名();
    类名(类名 &对象);
};
```

- 复制构造函数是特殊的构造函数，有构造函数的特性，形参是本类对象的引用
- 作用是用一个存在的对象去初始化同类的另一个新对象
- 如果没有定义类的构造函数，系统会自动生成一个隐含的复制构造函数
- 这个隐含的复制构造函数的作用是把初始值对象的每一个数据成员的值都复制到新建立的对象

- 复制构造函数在以下情况会被默认调用
  - 用类来初始化该类的另一个对象时
  - 函数的形参是类的对象 
  - 函数的返回值是类的对象

### 4.3.3 析构函数

```c++
class 类名{
public:
	~类名();
};
```

- 构造函数用于完成对象被删除前的一些清理工作
- 构造函数是在独享的生存期即将结束的时刻被自动调用
- 构造函数是共有函数，名称由类名前加"~"，没有返回值，不接受任何参数
- 不进行显示说明，系统自动生成一个函数体为空的而隐含析构函数
- 如果人们希望对象被删除之前时刻西东完成某些事情，就可以将他们把他们写进析构函数中

### 4.4 类的组合

#### 4.4.1 组合

- 类的组合描述即使一个类内嵌其他类的对象做为成员

- 当创建类的时候，如果这个类具有内嵌对象成员，那么这个内嵌对象成员将首先被自动创建

- 创建对象时，纪要对本类的基本数据类型进行初始化，也要对内嵌对象成员进行初始化

- 一般的定义形式

- ```C++
  类名::类名(形参表):内嵌对象1(形参表),内嵌对象2(形参表)...
  {
  	类的初始化
  }
  ```

- 构造函数的调用顺序如下
  - 调用内嵌对象的构造函数，点哟ing顺序按照内嵌对象在组合类真的定义中出现的次序
  - 内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序无关
  - 执行本类构造函数的函数体
  - 析构函数的执行顺序与构造函数刚好相反

#### 4.4.2 前向引用声明

- 出现两个类相互引用的情况，成为循环依赖

  ```c++
  class B;		前向引用声明
  class A{
  public:
  	void f(B b);
  };
  class B{
  public:
  	void g(A a);
  }
  ```

## ch05 数据的共享与保护

### 5.1 标识符作用域与可见性

#### 5.1.1 作用域

- 作用域是一个标识符在程序正文的有效区域、

##### 1 函数原型作用域

- 在函数原型申明的形式参数的作用域的范围就是函数原型作用域

  ```c++
  double fun(double r);
  ```

> 由于在函数原型的形参列表中起作用参数类型，标识符不起作用，因此可以省略

##### 2 局部作用域

- 函数形参列表中形参的作用域，从形参的声明开始，到整个函数的函数体结束之处为止
- 函数体内的变量，其作用域从声明开始，一直到声明所在的块结束的大括号为止

##### 3 类作用域

- 类作用域可以看成一组有名成员的集合，访问方法有如下三种
  - 如果在X的成员函数中没有声明同名的局部作用域标识符，那么该函数内可直接访问
  - 通过表达式x.m或者X::m
  - 通过ptr->m这样的表达式，其中ptr是只想X类的一个对象的指针

##### 4 命名空间作用域

- 命名空间的语法形式

  ```c++
  namespace 命名空间名{
  	命名空间内的各种声明(函数声明、类声明)
  }
  ```

- 引用其他命名空间的标识符

  ```c++
  命名空间名::标识符名
  ```

- 使用using语句引用命名空间

  ```c++
  using namespace 命名空间名
  ```

  

### 5.2 对象的生存期

### 5.3 类的静态成员

### 5.4 类的友元

### 5.5 共享数据的保护